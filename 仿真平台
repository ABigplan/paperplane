import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.ensemble import RandomForestRegressor
import io

# --- Configuration ---
st.set_page_config(page_title="纸飞机飞行性能仿真平台", layout="wide")

# --- Attempt to configure Matplotlib for Chinese characters ---
# This helps with displaying Chinese in plots
plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei', 'DejaVu Sans'] # 尝试几种中文字体
plt.rcParams['axes.unicode_minus'] = False # 解决负号 '-' 显示为方块的问题

# --- Session State Initialization ---
if 'experiment_data' not in st.session_state:
    st.session_state.experiment_data = pd.DataFrame()
if 'current_simulation_data' not in st.session_state:
    st.session_state.current_simulation_data = pd.DataFrame()
if 'analysis_results' not in st.session_state:
    st.session_state.analysis_results = {}
if 'interaction_results' not in st.session_state:
    st.session_state.interaction_results = {}

# --- Helper Functions ---
def simulate_flight(hardness, smoothness, weight, physics_engine="基础空气动力学"):
    """
    Simulates a paper airplane flight based on parameters.
    Returns a dictionary of flight characteristics.
    This is a placeholder simulation.
    """
    # Simple, deterministic simulation logic for demonstration.
    # In a real application, this would be a complex physics engine.
    np.random.seed(int((hardness * 100 + smoothness * 100 + weight * 100) % (2**32)))
    
    base_distance = 2.0
    base_time = 1.5
    base_max_height = 0.8
    base_yaw = 0.1
    base_stability = 0.9

    # Parameter effects (simplified and deterministic for demo)
    distance = base_distance + (hardness * 0.5) + (smoothness * 0.3) - (weight * 0.2) + np.random.normal(0, 0.1)
    time = base_time + (hardness * 0.2) + (smoothness * 0.4) - (weight * 0.3) + np.random.normal(0, 0.1)
    max_height = base_max_height + (hardness * 0.3) + (smoothness * 0.1) - (weight * 0.1) + np.random.normal(0, 0.05)
    yaw = base_yaw - (hardness * 0.05) - (smoothness * 0.1) + (weight * 0.15) + np.random.normal(0, 0.05)
    stability = base_stability + (hardness * 0.1) + (smoothness * 0.2) - (weight * 0.05) + np.random.normal(0, 0.05)
    
    # Ensure non-negative values
    distance = max(0, distance)
    time = max(0, time)
    max_height = max(0, max_height)
    stability = max(0, min(1, stability)) # Clamp between 0 and 1
    yaw = max(0, yaw)

    # Generate 3D trajectory data
    t = np.linspace(0, time, 50)
    x = distance * (t / time) # Simplified linear x
    y = max_height * np.sin(np.pi * t / time) # Parabolic height
    z = yaw * t # Linear yaw drift
    
    trajectory_df = pd.DataFrame({'t': t, 'x': x, 'y': y, 'z': z})

    return {
        "distance": round(distance, 2),
        "time": round(time, 2),
        "max_height": round(max_height, 2),
        "yaw": round(yaw, 2),
        "stability": round(stability, 2),
        "trajectory": trajectory_df
    }

def calculate_composite_score(row, weights):
    """Calculates a composite score based on weighted metrics."""
    score = (
        weights['distance'] * row['distance'] +
        weights['time'] * row['time'] +
        weights['max_height'] * row['max_height'] -
        weights['yaw'] * row['yaw'] + # Assume lower yaw is better
        weights['stability'] * row['stability']
    )
    return round(score, 2)

def run_batch_experiments(num_experiments):
    """Runs a batch of simulations with random parameters."""
    data = []
    for i in range(num_experiments):
        # Generate random parameters
        hardness = np.random.uniform(0.1, 1.0)
        smoothness = np.random.uniform(0.1, 1.0)
        weight = np.random.uniform(0.1, 1.0)
        
        # Run simulation
        results = simulate_flight(hardness, smoothness, weight)
        
        # Store results (统一列名格式)
        data.append({
            "Experiment_ID": i+1,
            "hardness": round(hardness, 2),
            "smoothness": round(smoothness, 2),
            "weight": round(weight, 2),
            "distance": results['distance'],
            "time": results['time'],
            "max_height": results['max_height'],
            "yaw": results['yaw'],
            "stability": results['stability'],
            "composite_score": 0 # Will be calculated later
        })
    
    df = pd.DataFrame(data)
    return df

def perform_analysis(df, target_column, feature_columns):
    """Performs linear regression and feature importance analysis."""
    if df.empty or target_column not in df.columns or not any(col in df.columns for col in feature_columns):
        st.warning("数据不足或列名不匹配，无法进行分析。")
        return None, None, None, None

    X = df[feature_columns]
    y = df[target_column]

    # Linear Regression
    lr_model = LinearRegression()
    lr_model.fit(X, y)
    y_pred_lr = lr_model.predict(X)
    r2_lr = r2_score(y, y_pred_lr)
    equation = f"{target_column} = "
    for i, coef in enumerate(lr_model.coef_):
        sign = '+' if coef >= 0 else '-'
        equation += f" {sign} {abs(coef):.2f}*{feature_columns[i]}"
    equation += f" + {lr_model.intercept_:.2f}"

    # Feature Importance (using Random Forest)
    rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_model.fit(X, y)
    importances = rf_model.feature_importances_
    feature_importance_df = pd.DataFrame({'Feature': feature_columns, 'Importance': importances}).sort_values(by='Importance', ascending=False)

    return r2_lr, equation, feature_importance_df, y, y_pred_lr

def perform_interaction_analysis(df, feature_columns):
    """Analyzes interaction effects between features."""
    if df.empty or len(feature_columns) < 2:
        st.warning("数据不足或特征少于2个，无法进行交互分析。")
        return None

    interactions = []
    for i in range(len(feature_columns)):
        for j in range(i+1, len(feature_columns)):
            feat1, feat2 = feature_columns[i], feature_columns[j]
            interaction_col = f"{feat1}_x_{feat2}"
            df[interaction_col] = df[feat1] * df[feat2]
            interactions.append(interaction_col)
    
    # Use Random Forest for interaction importance
    rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
    X_interaction = df[interactions]
    # For interaction analysis, let's use composite_score as target if available, otherwise Time
    target_for_interaction = 'composite_score' if 'composite_score' in df.columns else 'time'
    y_interaction = df[target_for_interaction]
    
    rf_model.fit(X_interaction, y_interaction)
    importances = rf_model.feature_importances_
    interaction_importance_df = pd.DataFrame({'Interaction': interactions, 'Importance': importances}).sort_values(by='Importance', ascending=False)
    
    return interaction_importance_df


# --- Main App Layout ---
st.title("纸飞机飞行性能数据处理与仿真实验平台")

# --- 1. Language & Theme (Simplified in Streamlit) ---
col1, col2 = st.columns(2)
with col1:
    language = st.selectbox("语言 / Language", ["中文", "English"])
with col2:
    # Streamlit has limited built-in theme switching, using dark theme as an option
    theme = st.selectbox("主题 / Theme", ["默认", "深色"])
    if theme == "深色":
        st.markdown("""
        <style>
            .stApp {
                background-color: #0e1117;
                color: #fafafa;
            }
            /* Add more dark theme styles as needed */
        </style>
        """, unsafe_allow_html=True)

# --- 2. Sidebar Parameter Adjustment ---
st.sidebar.header("参数调节 / Parameter Adjustment" if language=="中文" else "Parameter Adjustment")
hardness = st.sidebar.slider("硬度 / Hardness", 0.1, 1.0, 0.5, step=0.05)
smoothness = st.sidebar.slider("光滑度 / Smoothness", 0.1, 1.0, 0.5, step=0.05)
weight = st.sidebar.slider("重量 / Weight", 0.1, 1.0, 0.5, step=0.05)

st.sidebar.subheader("综合评分权重 / Composite Score Weights" if language=="中文" else "Composite Score Weights")
weight_distance = st.sidebar.slider("距离权重 / Distance Weight", 0.0, 1.0, 0.2, step=0.05)
weight_time = st.sidebar.slider("时间权重 / Time Weight", 0.0, 1.0, 0.2, step=0.05)
weight_height = st.sidebar.slider("高度权重 / Height Weight", 0.0, 1.0, 0.2, step=0.05)
weight_yaw = st.sidebar.slider("偏航权重 / Yaw Weight", 0.0, 1.0, 0.2, step=0.05)
weight_stability = st.sidebar.slider("稳定性权重 / Stability Weight", 0.0, 1.0, 0.2, step=0.05)

weights = {
    'distance': weight_distance,
    'time': weight_time,
    'max_height': weight_height,
    'yaw': weight_yaw,
    'stability': weight_stability
}

physics_engine = st.sidebar.selectbox(
    "仿真物理内核 / Physics Engine",
    ["基础空气动力学", "高级流体仿真 (Placeholder)"]
)

# --- 3. Single Simulation & Visualization ---
st.header("单组仿真与可视化 / Single Simulation & Visualization" if language=="中文" else "Single Simulation & Visualization")
if st.button("开始仿真 / Run Simulation"):
    with st.spinner("仿真运行中... / Simulation running..."):
        simulation_results = simulate_flight(hardness, smoothness, weight, physics_engine)
        composite_score = calculate_composite_score(
            pd.Series(simulation_results),
            weights
        )
        simulation_results["composite_score"] = composite_score
        
         # Store current simulation data (统一列名格式)
        st.session_state.current_simulation_data = pd.DataFrame([{
            "hardness": hardness, "smoothness": smoothness, "weight": weight,
            "distance": simulation_results['distance'],
            "time": simulation_results['time'],
            "max_height": simulation_results['max_height'],
            "yaw": simulation_results['yaw'],
            "stability": simulation_results['stability'],
            "composite_score": composite_score
        }])
        st.session_state.current_simulation_data['Trajectory'] = [simulation_results['trajectory']]

    st.subheader("仿真结果 / Simulation Results" if language=="中文" else "Simulation Results")
    
    # Display metrics in columns
    cols = st.columns(5)
    cols[0].metric("飞行距离 (m) / Distance (m)", simulation_results['distance'])
    cols[1].metric("飞行时间 (s) / Time (s)", simulation_results['time'])
    cols[2].metric("最大高度 (m) / Max Height (m)", simulation_results['max_height'])
    cols[3].metric("偏航 (°) / Yaw (°)", simulation_results['yaw'])
    cols[4].metric("稳定性 / Stability", f"{simulation_results['stability']:.2f}")

    st.metric("综合评分 / Composite Score", composite_score)

    st.subheader("3D飞行轨迹 / 3D Flight Path" if language=="中文" else "3D Flight Path")
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111, projection='3d')
    traj_df = simulation_results['trajectory']
    ax.plot(traj_df['x'], traj_df['z'], traj_df['y'], marker='o', linestyle='-', color='b')
    ax.set_xlabel('距离 Distance (m)')
    ax.set_ylabel('偏航 Yaw (m)')
    ax.set_zlabel('高度 Height (m)')
    ax.set_title('3D 飞行轨迹 / 3D Flight Path')
    st.pyplot(fig)

    st.subheader("详细数据 / Detailed Data" if language=="中文" else "Detailed Data")
    st.dataframe(st.session_state.current_simulation_data.drop(columns=['Trajectory']))

# --- 4. Batch Automatic Experiments ---
st.header("批量自动实验 / Batch Automatic Experiments" if language=="中文" else "Batch Automatic Experiments")
num_experiments = st.number_input("实验次数 / Number of Experiments", min_value=1, max_value=1000, value=10, step=10)
if st.button("开始批量实验 / Run Batch Experiments"):
    with st.spinner("批量实验运行中... / Batch experiments running..."):
        batch_df = run_batch_experiments(num_experiments)
        # Calculate composite scores for batch
        batch_df['composite_score'] = batch_df.apply(lambda row: calculate_composite_score(row, weights), axis=1)
        st.session_state.experiment_data = batch_df
    
    st.subheader("批量实验数据 / Batch Experiment Data" if language=="中文" else "Batch Experiment Data")
    st.dataframe(st.session_state.experiment_data)
    
    csv_buffer = io.StringIO()
    st.session_state.experiment_data.to_csv(csv_buffer, index=False)
    csv_data = csv_buffer.getvalue()
    
    st.download_button(
        label="导出数据 (CSV) / Export Data (CSV)",
        data=csv_data,
        file_name="paper_airplane_batch_data.csv",
        mime="text/csv"
    )

# --- 5. Scientific Analysis & Feature Explanation ---
st.header("科学分析与特征解释 / Scientific Analysis & Feature Explanation" if language=="中文" else "Scientific Analysis & Feature Explanation")

if not st.session_state.experiment_data.empty:
    analysis_data = st.session_state.experiment_data
elif not st.session_state.current_simulation_data.empty:
    analysis_data = st.session_state.current_simulation_data
else:
    analysis_data = pd.DataFrame()

if not analysis_data.empty:
    target_column = st.selectbox("选择分析目标 / Select Target", analysis_data.select_dtypes(include=[np.number]).columns.tolist())
    
    # --- Fix for Streamlit multiselect default values ---
    available_features = [col for col in analysis_data.columns if col != target_column and col != 'Experiment_ID' and col != 'Trajectory']
    # Ensure default features are actually in the available list
    default_features = [f for f in ["hardness", "smoothness", "weight"] if f in available_features]
    feature_columns = st.multiselect("选择分析特征 / Select Features", available_features, default=default_features)
    # --- End of fix ---

    if st.button("执行分析 / Perform Analysis"):
        with st.spinner("分析中... / Analyzing..."):
            r2, equation, feat_importance_df, y_true, y_pred = perform_analysis(analysis_data, target_column, feature_columns)
            if r2 is not None:
                st.session_state.analysis_results = {
                    'r2': r2, 'equation': equation, 'importance': feat_importance_df,
                    'y_true': y_true, 'y_pred': y_pred, 'target': target_column
                }
    
    if st.session_state.analysis_results:
        results = st.session_state.analysis_results
        st.subheader(f"R² 拟合优度 / R² Score: {results['r2']:.4f}")
        st.write(f"线性回归方程 / Linear Equation: `{results['equation']}`")
        
        st.subheader("特征重要性 / Feature Importance")
        st.dataframe(results['importance'])
        
        fig, ax = plt.subplots(figsize=(8, 5))
        sns.barplot(x='Importance', y='Feature', data=results['importance'], ax=ax)
        ax.set_title('特征重要性排名 / Feature Importance Ranking')
        st.pyplot(fig)

        st.subheader("残差分析 / Residual Analysis")
        residuals = results['y_true'] - results['y_pred']
        fig, ax = plt.subplots(1, 2, figsize=(12, 5))
        ax[0].scatter(results['y_pred'], residuals)
        ax[0].axhline(y=0, color='r', linestyle='--')
        ax[0].set_xlabel(f'预测 {results["target"]} / Predicted {results["target"]}')
        ax[0].set_ylabel('残差 / Residuals')
        ax[0].set_title('残差 vs 预测值 / Residuals vs Predicted')

        ax[1].hist(residuals, bins=20, edgecolor='black')
        ax[1].set_xlabel('残差 / Residuals')
        ax[1].set_ylabel('频率 / Frequency')
        ax[1].set_title('残差分布 / Residual Distribution')
        st.pyplot(fig)

else:
    st.info("请先进行单组仿真或批量实验以生成数据。 / Please run a single simulation or batch experiment to generate data.")

# --- 6. Material Interaction Analysis ---
st.header("材料特性交互影响分析 / Material Interaction Analysis" if language=="中文" else "Material Interaction Analysis")
all_features = ["hardness", "smoothness", "weight"]
if not analysis_data.empty:
    # --- Fix for Streamlit multiselect default values (Interaction Analysis) ---
    # Ensure default features for interaction are in the analysis data
    available_interaction_features = [f for f in all_features if f in analysis_data.columns]
    interaction_features = st.multiselect("选择用于交互分析的特征 / Select Features for Interaction", available_interaction_features, default=available_interaction_features)
    # --- End of fix ---
    
    if st.button("分析交互影响 / Analyze Interactions"):
        with st.spinner("交互分析中... / Analyzing interactions..."):
            interaction_importance_df = perform_interaction_analysis(analysis_data, interaction_features)
            if interaction_importance_df is not None:
                st.session_state.interaction_results = interaction_importance_df
    
    if st.session_state.interaction_results is not None and not st.session_state.interaction_results.empty:
        st.subheader("交互项重要性 / Interaction Importance")
        st.dataframe(st.session_state.interaction_results)
        
        fig, ax = plt.subplots(figsize=(8, 5))
        sns.barplot(x='Importance', y='Interaction', data=st.session_state.interaction_results, ax=ax)
        ax.set_title('交互项重要性排名 / Interaction Importance Ranking')
        st.pyplot(fig)
else:
    st.info("请先进行批量实验以生成足够数据进行交互分析。 / Please run batch experiments to generate data for interaction analysis.")
